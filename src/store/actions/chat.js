import ChatService from "../../services/chatService";

/* 
================================
manage dispatch types
================================
*/
import {
    FETCH_CHATS, SET_CURRENT_CHAT, 
    FRIENDS_ONLINE, FRIEND_ONLINE, FRIEND_OFFLINE, 
    SET_SOCKET, 
    RECEIVED_MESSAGE, SENDER_TYPING, PAGINATE_MESSAGES, INCREMENT_SCROLL, CREATE_CHAT,
    ADD_USER_TO_GROUP, LEAVE_CURRENT_CHAT, DELETE_CHAT
} from '../types'

/* 
================================
define actions that will then use the dispatch generic method as parameter, to alter global redux store through the reducers
================================
*/

export const fetchChats = () => dispatch => {
    return ChatService.fetchChats()
        .then(data => {
            data.forEach(chat => {
                chat.Users.forEach(user => {
                    user.status = 'offline'
                })
                chat.Messages.reverse() // to set correct ordering from older on top to recent on bottom in the list
            })
            console.log('Successfully fteched all current chats',data);
            dispatch({ type: FETCH_CHATS, payload: data })
            return data
        })
        .catch(err => {
            console.log('login auth error: ', err); throw err
        })
};

export const setCurrentChat = (chat) => dispatch => {
    dispatch({ type: SET_CURRENT_CHAT, payload: chat });
};

export const onlineFriends = (friends) => dispatch => {
    dispatch({ type: FRIENDS_ONLINE, payload: friends });
};

export const onlineFriend = (friend) => dispatch => {
    dispatch({ type: FRIEND_ONLINE, payload: friend });
};

export const offlineFriend = (friend) => dispatch => {
    dispatch({ type: FRIEND_OFFLINE, payload: friend });
};

export const setSocket = (socket) => dispatch => {
    dispatch({ type: SET_SOCKET, payload: socket });
};

export const receivedMessage = (message, userId) => dispatch => {
    dispatch({ type: RECEIVED_MESSAGE, payload: { message, userId } });
};

export const senderTyping = (sender) => dispatch => {
    dispatch ({type: SENDER_TYPING, payload: sender});
};

export const paginateMessages = (id, page) => dispatch => {
    return ChatService.paginateMessages(id, page)
        .then(({messages, pagination}) => {
            if(typeof messages !== 'undefined' && messages.length) {
                messages.reverse();
                const payload = {messages, id, pagination};
                dispatch ({type: PAGINATE_MESSAGES, payload});
                return true;
            }
            return false;
        })
        .catch( e => {throw e})
};

export const incrementScroll = () => dispatch => {
    dispatch ({type: INCREMENT_SCROLL, payload: null});
};

export const createChat = (chat) => dispatch => {
    dispatch({ type: CREATE_CHAT, payload: chat })
}

export const addUserToGroup = (group) => dispatch => {
    //linked to src/components/Chat/hooks/index.js in which we dispatch this present action 
    // .. after receiving an event from chat-backend repo (chat-backend/socket/index  => where we emit a 'added-user-to-group' in the socket.on('on('add-user-to-group') listener  )
    dispatch({ type: ADD_USER_TO_GROUP, payload: group })
}

export const leaveCurrentChat = (data) => dispatch => {
// event generated by the leaveChat helper function from the frontend (chat-frontend/src/utils/helpers/index.js => leaveChat Method)
            // complete process below:
                // 1) origin chat-frontend/src/components/Chat/components/ChatHeader/ChatHeader.js => ...{showChatOptions && ... <div onClick={()=>{leaveChat(chat.id, socketRef)}}>...<p>Leave...</p></div>}
                // 2) origin chat-frontend/src/utils/helpers.index.js => leaveChat() function ...
                //      2) bis  origin chat-frontend/src/services/chatService.js => leaveCurrentChat()
                //      2) ter  origin chat-backend/router/chat.js = route '/leave-current-chat' calling first the auth middleware to generate a req.user and then a leaveCurrentChat controller 
                //      2) quar origin chat-backend/controllers/chatController.js => leaveCurrentChat() controller
                // 3) ... the leaveChat() function in the 2) step has a .then(socketReference.emit('leave-current-chat', data)
                // 4) origin chat-backend/socket/index.jsa => socket.on('leave-current-chat') listener does a io.to(socket).emit('remove-user-from-chat'...') for all users to be notified, for all their corresponding socketsif they are connected on multiple devices
                // 5) origin chat-frontend/src/components/Chat/hooks/socketConnectTry.js has a listener for 'remove-user-from-chat', that dispatched a leaveCurrentChat() method
                // 6) and we arrive HERE!
    dispatch({ type: LEAVE_CURRENT_CHAT, payload: data })
}

export const deleteCurrentChat = (chatId) => dispatch => {
    dispatch({ type: DELETE_CHAT, payload: chatId })
}


